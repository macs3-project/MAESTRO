---
title: "scRNA-seq custom analysis"
author: "Gali Bai"
date: "2021-06-07"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Perform custom analysis from the pipeline output

Although MAESTRO will generate all the analysis results through the snakemake-based workflow, in most cases, users might focus on specific clusters or sub-clusters or want to tune some of the parameters to improve the results. Then users can utilize the stand-alone MAESTRO R package, which has been installed in the MAESTRO conda environment, to perform custom analysis from the processed dataset (gene by cell count matrix). We will show you how to run through the downstream analysis using the R package step by step.

### Step 0. Read data

First users need to read the gene expression count matrix generated by MAESTRO pipeline into the R environment. To support the processing of large datasets, in MAESTRO we use [HDF5 format](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/advanced/h5_matrices) for all the expression, atac-seq peak count and RP tables.

```{r}
library(MAESTRO)
library(Seurat)
#Here, user need to get the .h5 matrix under path scRNA/pbmc_1k_v3/Result/QC/pbmc_1k_v3_filtered_gene_count.h5
pbmc.gene <- Read10X_h5("./data/scrna/pbmc_1k_v3_filtered_gene_count.h5")
```

We also support the processed dataset from 10x Cell Ranger pipeline or STARsolo. Users can load the gene matrix into R through `Read10X` function in Seurat package

```{r, eval=FALSE}
pbmc.gene <- Read10X('Result/STAR/pbmc_1k_v3Solo.out/Gene/filtered')
```

### Step 1. Perform clustering and differential gene analysis
We next create a Seurat object using the gene expression matrix and perform the clustering analysis as well as differential gene analysis for different clusters. `RNARunSeurat()` function in MAESTRO integrates multiple functions of Seurat and perform the routine analysis as follows.

1. **Single-cell level quality control**
* **Cell and gene coverage:**
Cells with less than 200 genes expressed, and genes expressed in less than 10 cells will be removed from the analysis.
* **Mitochondrial gene and ERCC:**
If `mito = TRUE` and `mito.cutoff = 20` is set, we will also filter the cells with more than 20% mitochondrial reads or more than 5% ERCC spike-ins. Mitochondrial genes are expressed in most cells and their expression level is specific to cell types. High expression level (i.e., high percentage) of mitochondrial genes could be detected from apoptotic or lysing cells, which should not be included in the analysis. ERCC spike-ins are used to estimate total mRNA content captured in cells. High level of ERCC is likely caused by cell death. Similarly, cells with a high percentage of ERCC need to be filtered.
2. **Normalization**
* **Removing unwanted confounding factors:**
Single cells may contain unwanted sources of variation, such as technical noise. These factors may have a disturbing effect on downstream analysis and should be removed out. Seurat provides a function to regress user-defined variables out.
* **Variance shrinkage and high-variance gene identification:**
Based on the assumption that the expression level of most genes in all cells is similar, variance adjustment is needed to preserve biological variation and minimize unknown experiment variation. After shrinking variance, really highly variable genes are identified and only the top 2000 variable genes are used in the downstream analysis.
3. **Analysis**
* **Dimension reduction and determining significant components:**
MAESTRO performed PCA on top variable features to reduce the dimension of the dataset. An elbow plot is generated to visualize the variance of each PC and identify the "elbow" point to determine the significant PCs. If not set, the top 15 PCs will be selected by default for downstream analysis.
* **Clustering:**
MAESTRO employs the graph-based clustering method in Seurat for scRNA-seq clustering analysis. Please see [Seurat](https://www.cell.com/cell/pdf/S0092-8674(19)30559-8.pdf) for the details. Briefly, MAESTRO will build a K-nearest neighbor (KNN) graph using the reduced dimensions from the previous step, and then refine the edge weights between two cells based on the Jaccard similarity of their neighborhoods, which are completed by the `FindNeighbors` function in Seurat. To cluster the cells, MAESTRO uses the `FindClusters` function in Seurat, which applies the Louvain algorithm to cluster cells together iteratively. The default clustering resolution for scRNA-seq is set to 0.6, and users can also tune the parameter for different conditions. Besides, extra parameters for `FindNeighbors` and `FindClusters` can be passed via `findneighbors.args` and `findclusters.args`. For example, users can set `findneighbors.args = list(k.param = 25)` to define k = 25 for the k-nearest neighbor algorithm.
* **UMAP visualization:**
UMAP is used to visualize all the single cells. MAESTRO adopts [UMAP](https://arxiv.org/abs/1802.03426) to achieve a low dimension embedding, in which similar cells are placed together. To get a better result for visualization, users can tune the parameters of `RunUMAP` by adding the arguments in `RNARunSeurat` function, like `RNARunSeurat(inputMat = pbmc.gene, ..., n.neighbors = 20, min.dist = 0.2)`.
* **Differential gene analysis:**
The default differential expression method is [presto](https://github.com/immunogenomics/presto), a fast version of Wilcoxon test. Users can also use other model-based methods like [DESeq2](https://bioconductor.org/packages/release/bioc/html/DESeq2.html) and [MAST](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4676162/). These methods have been integrated into `FindAllMarkers` function in Seurat. We provide `FindAllMarkersMAESTRO` function in MAESTRO, which is adapted from `FindAllMarkers`, to reduce the computational time and memory. Genes with logFC greater than 0.25, minimum presence faction in cells of 0.1, and p-value less than 1E-5 are identified as marker genes for each cluster.

```{r}
pbmc.RNA.res <- RNARunSeurat(inputMat = pbmc.gene,
                               project = "pbmc_1k_v3",
                               orig.ident = NULL,
                               min.c = 10,
                               min.g = 200,
                               mito = TRUE,
                               mito.cutoff = 20,
                               variable.genes = 2000,
                               organism = "GRCh38",
                               dims.use = 1:15,
                               cluster.res = 0.6,
                               only.pos = FALSE,
                               genes.test.use = "presto",
                               genes.cutoff = 1e-05,
                               genes.pct = 0.1,
                               genes.logfc = 0.25,
                               outdir = "./docs/assets/scrna/")

```


`RNARunSeurat()` generates plots of QC and clustering in the current working directory, and returns a list of a Seurat object `RNA` and dataframe `genes`. Please see [Seurat Github wiki](https://github.com/satijalab/seurat/wiki) for more details of the Seurat object structure. Users can use the `str()` command to get an intuitive understanding of the object.

```{r}
pbmc.RNA.res$RNA

head(pbmc.RNA.res$genes)
```

In the `outdir/` directory you will find the following outputs:

```{r echo=FALSE}
knitr::include_graphics("assets/scrna/pbmc_1k_v3.spikein.png", error = FALSE,)
knitr::include_graphics("assets/scrna/pbmc_1k_v3_PCElbowPlot.png", error = FALSE)
knitr::include_graphics("assets/scrna/pbmc_1k_v3_cluster.png", error = FALSE)

```

### Step 2. Annotate cell types
We next try to annotate different clusters based on their marker genes. We use public immune signatures like [CIBERSORT](https://www.nature.com/articles/nmeth.3337) to annotate the clusters. Users can also use their signatures to annotate the clusters. Cell type information is stored in `Object@meta.data$assign.ident`.

```{r}
data(human.immune.CIBERSORT)
pbmc.RNA.res$RNA <- RNAAnnotateCelltype(RNA = pbmc.RNA.res$RNA,
                                          gene = pbmc.RNA.res$genes,
                                          signatures = "human.immune.CIBERSORT",
                                          min.score = 0.05,
                                          outdir = "./docs/assets/scrna/")
head(pbmc.RNA.res$RNA@meta.data)
```

```{r echo=FALSE}
knitr::include_graphics("assets/scrna/pbmc_1k_v3_annotated.png", error = FALSE)
```

All the reduction results are stored in `Object@reductions`. For example, users can use `Object@reductions$umap@cell.embeddings` to extract the cell embedding result of UMAP for custom plotting. Or users can directly use `DimPlot()` from Seurat and other functions like `theme()` from ggplot2 to generate a prettier plot.

```{r}
library(ggplot2)
library(RColorBrewer)
DimPlot(object = pbmc.RNA.res$RNA, label = TRUE, pt.size = 0.15,
        group.by = "assign.ident", label.size = 3,
        cols = brewer.pal(8,"Set2")) +
        theme_linedraw() + NoLegend()

```

### Step 3. Identify driver transcription regulators
To identify enriched transcription regulators is crucial to understanding gene regulation in the heterogeneous single-cell populations. MAESTRO utilizes LISA to predict the potential transcription factors based on the marker genes in each cluster, which rely on the transcriptional regulator binding profiles from CistromeDB to identify the potential regulators shaping the expression pattern of each cluster. In rare cases, users need to download LISA data manually. If the program fails while downloading data, follow this [LISA document](https://github.com/liulab-dfci/lisa2/blob/master/docs/troubleshooting.md). If users have multiple clusters of differential genes, the "multi" mode is recommended.

```{r,eval=TRUE}
pbmc.RNA.tfs <- RNAAnnotateTranscriptionFactor(RNA = pbmc.RNA.res$RNA,
                                                 genes = pbmc.RNA.res$genes,
                                                 project = pbmc.RNA.res$RNA@project.name,
                                                 organism = "GRCh38",
                                                 lisa.path = "/Users/galib/miniconda3/envs/lisa_env/bin/.venvs/lisa_env/bin/lisa",
                                                 top.tf = 10,
                                                 outdir = "./docs/assets/scrna/")
pbmc.RNA.tfs[["0"]]
```

Besides identifying TFs for all the clusters, we also support the differential gene list from a single comparison.
```{r, eval = TRUE}
de.geneset <- FindMarkersMAESTRO(pbmc.RNA.res$RNA, ident.1 = c(3))
pbmc.RNA.monocyte.tfs <- RNAAnnotateTranscriptionFactor(RNA = pbmc.RNA.res$RNA,
                                                          genes = de.geneset,
                                                          cluster = c(3),
                                                          project = "pbmc_1k_v3_Monocyte",
                                                          organism = "GRCh38",
                                                          top.tf = 20,
                                                          lisa.path = "/Users/galib/miniconda3/envs/lisa_env/bin/.venvs/lisa_env/bin/lisa",
                                                          outdir = "./docs/assets/scrna/")
```

### Step 4. Visualize driver transcription factors for each cluster  
According to the annotation of the clusters, we know that cluster 3 is Monocyte. Next, we want to visualize the enriched regulators in Monocyte from Step 5.

The output TFs returned from `RNAAnnotateTranscriptionFactor` have already been pre-filtered based on TF expression level.
```{r, eval = TRUE}
tfs <- sapply(pbmc.RNA.monocyte.tfs[[1]], function(x){
                return(unlist(strsplit(x, split = " | ", fixed = TRUE))[1])})
VisualizeTFenrichment(TFs = tfs,
                             cluster.1 = 3,
                             type = "RNA",
                             SeuratObj = pbmc.RNA.res$RNA,
                             LISA.table = "pbmc_1k_v3_Monocyte_lisa.txt",
                             visual.totalnumber = 100,
                             name = "pbmc_1k_v3_Monocyte_filtered")

```

If users want to visualize the top factors without filtering. Please leave the TFs to NULL, then the top 10 regulators will be visualized.
```{r,eval=TRUE}
VisualizeTFenrichment(cluster.1 = 3,
                             type = "RNA",
                             SeuratObj = pbmc.RNA.res$RNA,
                             LISA.table = "pbmc_1k_v3_Monocyte_lisa.txt",
                             visual.topnumber = 10,
                             visual.totalnumber = 100,
                             name = "pbmc_1k_v3_Monocyte_top")

```

To further filter the regulators, users may want to visualize the expression level of the predicted transcription factors. We provide the function for visualize TF/genes expression level using Vlnplot and Umap.
```{r}
VisualizeVlnplot(genes = c("SPI1","CEBPB"),
                        type = "RNA",
                        SeuratObj = pbmc.RNA.res$RNA,
                        ncol = 2,
                        width = 8.5,
                        height = 4,
                        name = "pbmc_1k_v3_Monocyte")
```

```{r}
VisualizeUmap(genes = c("SPI1","CEBPB"),
                     type = "RNA",
                     SeuratObj = pbmc.RNA.res$RNA,
                     ncol = 2,
                     width = 8,
                     height = 3,
                     name = "pbmc_1k_v3_Monocyte")

```


### Step 5. Save the object for future analysis
Finally, users can save the R object, including the raw data, normalized data, clustering result, and meta information for future analysis.

```{r}
saveRDS(pbmc.RNA.res, "pbmc_1k_v3_8k_res.rds")
```

