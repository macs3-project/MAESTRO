---
title: "scATAC-seq custom analysis"
author: "baigal628"
date: "2021-06-07"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Perform custom analysis from the pipeline output

Although MAESTRO will generate all the analysis results through the snakemake-based workflow, in most cases, users might focus on specific clusters or sub-clusters or want to tune some of the parameters to improve the results. Then users can utilize the stand-alone MAESTRO R package, which has been installed in the MAESTRO conda environment, to perform custom analysis from the processed dataset (peak by cell binary matrix). We will show you how to run through the downstream analysis using the R package step by step.

## Step 0. Read data
First users need to read the peak count matrix as well as the gene regulatory potential matrix generated by MAESTRO into the R enviroment. To support the processing of large datasets, in MAESTRO we use [HDF5 format](https://support.10xgenomics.com/single-cell-atac/software/pipelines/latest/advanced/h5_matrices) for all the expression, atac-seq peak count and RP tables.

```{r}
library(MAESTRO)
library(Seurat)
library(Signac)
pbmc.peak <- Read10X_h5('./data/scatac/atac_pbmc_500_nextgem_filtered_peak_count.h5')
pbmc.gene <- Read10X_h5('./data/scatac/atac_pbmc_500_nextgem_gene_score.h5')
```

We also support the processed dataset from 10x Cell Ranger pipelines, users can load the peak matrix into R through Seurat package. Then users can generate the gene regulatory score matrix by the following command. See [tutorial](../Gene_activity_modelling/Gene_activity_modelling.md) of gene activity modelling for more details.

```{r, eval = FALSE}
pbmc.peak <- Read10X_h5("outs/filtered_peak_bc_matrix.h5")
pbmc.gene <- ATACCalculateGenescore(pbmc.peaks, organism = "GRCh38")
```

**Note:** If MAESTRO R package is not managed through miniconda, users may encounter the following error.

Error: Python shared library not found, Python bindings not loaded.
Use reticulate::install_miniconda() if you'd like to install a Miniconda Python environment.

It means reticulate R package cannot find the python shared library. If Anaconda has been installed, users just need to specify an alternate version of python, for example:

```{r, eval = FALSE}
library(reticulate)
use_python("/usr/miniconda3/bin/python", required = TRUE)
pbmc.gene <- ATACCalculateGenescore(pbmc.peak)
```

If users don't install Miniconda or Anaconda, we recommend to use `reticulate::install_miniconda()` to install a Miniconda Python environment and specify the version through `use_python`.

### Step 1. Perform clustering analysis and differential peak calling    
We next create a Seurat object using the peak count matrix and perform the clustering analysis as well as differential peak calling for different clusters. `ATACRunSeurat()` function in MAESTRO integrates multiple functions of Seurat and perform the routine analysis as follows.

**Analysis**
* **Dimension reduction:**
MAESTRO first performs dimension reduction on the input matrix. As we and others reported [(Cusanovich et al, Science 2015)](https://science.sciencemag.org/content/348/6237/910/tab-pdf), the Latent Semantic Index (LSI) has been widely used in learning the structure of scATAC-seq data. We use LSI as the default dimension reduction method, which has the best performance according to our benchmark. Users can tune the parameters of `RunLSI` via `runlsi.args`. For example, users can set `runlsi.args = list(n = 30)` to define the number of singular values to compute LSI. We also provide PCA as an optional method.  
* **Clustering:**
MAESTRO employs the graph-based clustering method in Seurat for scATAC-seq clustering analysis. Please see [Seurat](https://www.cell.com/cell/pdf/S0092-8674(19)30559-8.pdf) for the details. Briefly, MAESTRO will build a K-nearest neighbor (KNN) graph using the reduced dimensions from the previous step, and then refine the edge weights between two cells based on the Jaccard similarity of their neighborhoods, which are completed by the `FindNeighbors` function in Seurat. To cluster the cells, MAESTRO uses the `FindClusters` function in Seurat, which applies the Louvain algorithm to cluster cells together iteratively. The default clustering resolution for scATAC-seq is set to 0.6, and users can also tune the parameter for different conditions. Besides, extra parameters for `FindNeighbors` and `FindClusters` can be passed via `findneighbors.args` and `findclusters.args`. For example, users can set `findneighbors.args = list(k.param = 25)` to define k = 25 for the k-nearest neighbor algorithm.
* **UMAP visualization:**
UMAP is used to visualize all the single cells. MAESTRO adopts [UMAP](https://arxiv.org/abs/1802.03426) to achieve a low dimension embedding, in which similar cells are placed together. To get a better result for visualization, users can tune the parameters of `RunUMAP` by adding the arguments in `ATACRunSeurat` function, like `ATACRunSeurat(inputMat = pbmc.gene, ..., n.neighbors = 20, min.dist = 0.2)`.
* **Differential peak calling:**
MAESTRO adopts a [wilcox-test](https://www.tandfonline.com/doi/abs/10.1080/01621459.1972.10481279) based method to identify the differential peaks for each cluster. The original peak count matrix is scaled and weighed by the total peaks present in each cell to overcome the potential ties in Wilcox-test. It will take 10-20mins to calculate the differential peaks for all the clusters. We provide `FindAllMarkersMAESTRO` function in MAESTRO, which is adapted from `FindAllMarkers` of Seurat, to reduce the computational time and memory. Peaks with logFC greater than 0.2, minimum presence faction in cells of 0.1, and p-value less than 1E-5 are identified as differential peaks for each cluster.

```{r}
pbmc.ATAC.res <- ATACRunSeurat(inputMat = pbmc.peak,
                                 project = "atac_pbmc_500_nextgem",
                                 min.c = 50,
                                 min.p = 500,
                                 method = "LSI",
                                 dims.use = 1:30,
                                 cluster.res = 0.6,
                                 only.pos = TRUE,
                                 peaks.test.use = "presto",
                                 peaks.cutoff = 1e-05,
                                 peaks.pct = 0.1,
                                 peaks.logfc = 0.2,
                                 outdir = "./docs/assets/scatac/")

```

`ATACRunSeurat()` returns a list of a Seurat object `ATAC` and dataframe `peaks`. Please see [Seurat Github wiki](https://github.com/satijalab/seurat/wiki) for more details of the Seurat object structure. Users can use the `str()` command to get an intuitive understanding of the object.

```{r}
pbmc.ATAC.res$ATAC

head(pbmc.ATAC.res$peaks)
```

```{r echo=FALSE}
knitr::include_graphics("assets/scatac/atac_pbmc_500_nextgem_cluster.png", error = FALSE)
```

### Step 2. Annotate cell types
We next try to annotate different clusters based on their marker genes. For scATAC, MAESTRO provides two methods to annotate cell types. One is based on inferred gene activity. MAESTRO uses the gene regulatory potential (RP model, see the paper for more details) to quantify gene expression. So, we first need to use `ATACAttachGenescore()` to pass the gene regulatory potential matrix to the clustering result, and then perform differential gene analysis for each cluster on the gene RPscore matrix and identify the marker genes. We use public immune signatures like [CIBERSORT](https://www.nature.com/articles/nmeth.3337) to annotate the clusters. Users can also use their own signatures to annotate the clusters. Cell type information is stored in `Object@meta.data$assign.ident`.

```{r}
pbmc.ATAC.res$ATAC <- ATACAttachGenescore(ATAC = pbmc.ATAC.res$ATAC, RPmatrix = pbmc.gene)
data(human.immune.CIBERSORT)
pbmc.ATAC.res$ATAC <- ATACAnnotateCelltype(ATAC = pbmc.ATAC.res$ATAC,
                                             signatures = human.immune.CIBERSORT,
                                             min.score = 0.1,
                                             genes.test.use = "presto",
                                             genes.cutoff = 1E-5,
                                             outdir = "./docs/assets/scatac")
```

```{r}
head(pbmc.ATAC.res$ATAC@meta.data)
```


```{r echo=FALSE}
knitr::include_graphics("assets/scatac/atac_pbmc_500_nextgem_annotated.png", error = FALSE)
```

Another method `ATACAnnotateChromatinAccessibility` to annotate scATAC-seq data is based on chromatin accessibility directly. MAESTRO incorporates public bulk chromatin accessibility data (DNase-seq and ATAC-seq) from Cistrome database. All the datesets are clustered into 80 clusters and the cluster identities are determined by the cell-type or tissue type information of datasets within each cluster. For scATAC-seq clusters, MAESTRO utilizes giggle to evaluate the enrichment of bulk chromatin accessibility peaks on cluster-specific peaks from scATAC-seq data. Then the Cistrome cluster identity from the most enriched bulk chromatin accessibility data is used to represent the cell-type annotation for the scATAC-seq cluster. Giggle has been installed in the MAESTRO conda environment. If users only installed the stand-alone R pcakage, please install [giggle](https://github.com/ryanlayer/giggle) first. Users need to download the giggle index from [Cistrome website](http://cistrome.org/~galib/giggle.all.tar.gz) (**Note:** If the version of MAESTRO is higher than v1.2.0, please update the giggle index to the [latest](http://cistrome.org/~galib/giggle.all.tar.gz)), and provide the file location of the index to `ATACAnnotateChromatinAccessibility`. Cell type annotation based on bulk chromatin accessibility data is stored in `Object@meta.data$biological_resource`.

```{r, eval = FALSE}
pbmc.ATAC.res$ATAC <- ATACAnnotateChromatinAccessibility(ATAC = pbmc.ATAC.res$ATAC,
                                                  peaks = pbmc.ATAC.res$peaks,
                                                  project = "atac_pbmc_500_nextgem",
                                                  giggle.path = "/Users/galib/Downloads/giggle.all",
                                                  organism = "GRCh38")

p <- DimPlot(pbmc.ATAC.res$ATAC, label = TRUE, reduction = "umap", group.by = "biological_resource", repel=T, pt.size = 0.5, label.size = 2.5)
ggsave(file.path(paste0(result$ATAC@project.name, "_CistromeTop_annotated.png")), p, width=7.5, height=4)

```

All the reduction results are stored in `Object@reductions`. For example, users can use `Object@reductions$umap@cell.embeddings` to extract the cell embedding result of UMAP for custom plotting. Or users can directly use `DimPlot()` from Seurat and other functions like `theme()` from ggplot2 to generate a prettier plot.

```{r}
library(ggplot2)
library(RColorBrewer)
p2 <- DimPlot(object = pbmc.ATAC.res$ATAC, label = TRUE, pt.size = 0.15,
               group.by = "assign.ident", label.size = 3,
               cols = brewer.pal(8,"Set2")) +
       theme_linedraw() + NoLegend()
p2
```

### Step 3. Identify driver transcription regulators  
To identify enriched transcription regulators is crucial to understanding gene regulation in the heterogeneous single-cell populations. MAESTRO utilizes giggle to identify enrichment of transcription factor peaks in scATAC-seq cluster-specific peaks.

After identifying enriched transcription regulators, MAESTRO also provides the potential target gene list of the top 10 transcription factors for each cluster, which are based on the ChIP-seq profiles from [CistromeDB](http://cistrome.org/db/#/). The target genes will be generated in the `project.GIGGLE` directory.

```{r, eval = FALSE}
pbmc.ATAC.tfs <- ATACAnnotateTranscriptionFactor(ATAC = pbmc.ATAC.res$ATAC,
                                                   peaks = pbmc.ATAC.res$peaks,
                                                   project = "atac_pbmc_500_nextgem",
                                                   giggle.path = "/Users/galib/Downloads/giggle.all")
pbmc.ATAC.tfs[["0"]]
```

Besides indentifying TFs for all the clusters, we also support the differential peaks from a single comparison.

```{r,eval=FALSE}
DefaultAssay(pbmc.ATAC.res$ATAC) = "ATAC"
de.peakset <- FindMarkersMAESTRO(pbmc.ATAC.res$ATAC, ident.1 = c(0,2,10,12))
pbmc.ATAC.monocyte.tfs <- ATACAnnotateTranscriptionFactor(ATAC = pbmc.ATAC.res$ATAC,
                                                            peaks = de.peakset,
                                                            cluster = c(0,2,10,12),
                                                            project = "atac_pbmc_500_nextgem",
                                                            giggle.path = ""/Users/galib/Downloads/giggle.all")
```


Visualize driver transcription factors for each cluster
According to the annotation of the clusters, we know that cluster 4 is Monocytes. Next, we want to visualize the enriched regulators in Monocytes from 

### Step 4. Visualize driver transcription factors for each cluster

Visualize driver transcription factors for each cluster
According to the annotation of the clusters, we know that cluster 4 is Monocytes. Next, we want to visualize the enriched regulators in Monocytes from Step4. 

The output TFs from MAESTRO have already been pre-filtered using TF regulatory potential score.
```{r, eval = FALSE}
tfs <- sapply(pbmc.ATAC.tfs[["1"]], function(x) {return(unlist(strsplit(x, split = " | ", fixed = TRUE))[1])})
p <- VisualizeTFenrichment(TFs = tfs,
                             cluster.1 = 4,
                             type = "ATAC",
                             SeuratObj = pbmc.ATAC.res$ATAC,
                             GIGGLE.table = "atac_pbmc_500_nextgem.PredictedTFScore.txt",
                             visual.totalnumber = 100,
                             name = "atac_pbmc_500_nextgem_Monocyte_filtered")
```


If users want to visualize the top factors without filtering using regulatory potential. Please leave the TFs to blank, then the top 10 regulators will be visualized.

```{r, eval = FALSE}
VisualizeTFenrichment(cluster.1 = 4,
                             type = "ATAC",
                             SeuratObj = pbmc.ATAC.res$ATAC,
                             GIGGLE.table = "atac_pbmc_500_nextgem_giggle.txt",
                             visual.topnumber = 10,
                             visual.totalnumber = 100,
                             name = "atac_pbmc_500_nextgem_Monocyte_top")

```


To further filter the regulators, users may want to visualize the expression level of the predicted transcription factors. Here, we use the gene regulatory potential score as the predicted gene expression level. We provide the function for visualize TF/genes regulatory potential using Vlnplot and Umap.
```{r}
VisualizeVlnplot(genes = c("SPI1","RARA"),
                        type = "ATAC",
                        SeuratObj = pbmc.ATAC.res$ATAC,
                        ncol = 2,
                        width = 9,
                        height = 4,
                        name = "atac_pbmc_500_nextgem_Monocyte")

```


```{r}
VisualizeUmap(genes = c("SPI1","RARA"),
                     type = "ATAC",
                     SeuratObj = pbmc.ATAC.res$ATAC,
                     ncol = 2,
                     width = 8,
                     height = 3,
                     name = "atac_pbmc_500_nextgem_Monocyte")

```


Based on the regulatory potential of TFs, we can see that SPI1 is highly expressed in the Monocytes from PBMC, while RARA is generally distributed among all cell-types.

MAESTRO can also provide a genome browser function `ATACViewTrack` for visualizing the scATAC-seq signal for different clusters. The fragment file `fragments_corrected_count.tsv.gz` and its index `fragments_corrected_count.tsv.gz.tbi` are needed for this function. If users start from the output of 10x Cell Ranger pipeline, `fragments.tsv.gz` and `fragments.tsv.gz.tbi` are the substitutes.

```{r, eval=FALSE}
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)
txdb = TxDb.Hsapiens.UCSC.hg38.knownGene
genome = "hg38"
fragment = "../Mapping/fragments_corrected_count.tsv.gz"

meta_info = data.frame(cell = rownames(pbmc.ATAC.res[["ATAC"]]@meta.data),
                       cluster = pbmc.ATAC.res[["ATAC"]]@meta.data$seurat_clusters,
                       depth = pbmc.ATAC.res[["ATAC"]]@meta.data$nCount_ATAC)

ATACViewTrack(gene_name = "SPI1", downstream = 8000,
              yaxis_cex = 1,
              fragment = fragment,
              grouping = meta_info,
              tick_label_cex = 1, tick.dist = 5000,
              track_cols = "blue",
              label_cex = 1,
              minor.tick.dist = 1000, label.margin = -0.6,
              txdb = txdb,
              genome = genome)
```


### Step 5. Save the project for future analysis
Finally, users can save the R project, including the raw data, normalized data, clustering result, and meta information for future analysis.

```{r, eval = FALSE}
saveRDS(pbmc.ATAC.res, "atac_pbmc_500_nextgem_res.rds")
```

The differential peaks, predicted TFs, and target genes and all the figures have already been saved in the current directory by MAESTRO.
